colo molokai

" General {
    set fileencodings=ucs-bom,utf-8,gbk
    set fileformats=unix,dos,mac
    set tags=tags;
    set ambiwidth=double
    set laststatus=2
    set autowriteall
    set scrolljump=0
    set scrolloff=0
    set nospell
    set clipboard&

    set wildignore+=*-target,target
" }

" Key Mapping {
    vunmap <
    vunmap >

    nmap gp "0p
    nmap gP "0P
    map <Leader>sh :sh<CR>
    cmap <C-A> <Home>
    cmap <C-E> <End>

    " map double j to <esc>, double <esc> to avoid NeoComplCache <esc> bug.
    imap <silent> jj <esc><esc>:w<cr>

    " F7/F8 to jump to next/prev diff / location-list {
    " @see http://vim.wikia.com/wiki/Selecting_changes_in_diff_mode
        if &diff
            let g:origCursorPos=getpos('.')
            autocmd WinEnter * :call setpos('.', g:origCursorPos)
            autocmd WinLeave * :let g:origCursorPos=getpos('.')
            nmap <F7> [c
            nmap <F8> ]c
        else
            map <F7> :lprev<cr>
            map <F8> :lnext<cr>
        endif
    " }

    " Visual block search {
        function! VisualSearch(direction) range
            let l:saved_reg = @"
            execute "normal! vgvy"

            let l:pattern = escape(@", '\\/.*$^~[]')
            let l:pattern = substitute(l:pattern, "\n$", "", "")

            if a:direction == 'b'
                execute "normal ?" . l:pattern . ""
            elseif a:direction == 'f'
                execute "normal /" . l:pattern . ""
            endif

            let @/ = l:pattern
            let @" = l:saved_reg
        endfunction

        vnoremap <silent> * :call VisualSearch('f')<CR>
        vnoremap <silent> # :call VisualSearch('b')<CR>
    " }

    " Swap 0 and ^ {
        nnoremap 0 ^
        nnoremap ^ 0
        nnoremap d0 d^
        nnoremap d^ d0
        nnoremap c0 c^
        nnoremap c^ c0
        nnoremap s0 s^
        nnoremap s^ s0
        nnoremap y0 y^
        nnoremap y^ y0
    " }
" }

" Plugins {
    " CtrlP {
        nmap <silent> <C-j> :CtrlPTag<cr>
        nmap <silent> <space> :CtrlPMRUFiles<cr>

        let g:ctrlp_regexp = 1
        let g:ctrlp_cmd = 'CtrlPMixed'
        let g:ctrlp_max_files = 10000

        unlet g:ctrlp_custom_ignore
        let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn)$'
    " }

    " Switch.vim {
        nnoremap - :Switch<cr>
    " }

    " NerdTree {
        unmap <leader>e
    " }

    " Ack {
        nmap <F3> :LAck <C-R><C-W>
    " }

    " NeoComplCache {
        function! ToggleSnipple()
            if &ft == 'snippet'
                w!
                edit #
                bdelete #
            else
                NeoComplCacheEditSnippets
            endif
        endfunction

        let g:neocomplcache_snippets_dir = neocomplcache_snippets_dir . ",~/.vim/bundle/fenbi-snippet/snippets"
        nmap <F9> :call ToggleSnipple()<CR>
    " }

    " ZenCoding {
        let g:user_zen_leader_key = '<c-l>'
    " }
" }

" File type {
    " Git Commit {
        au BufNewFile,BufRead COMMIT_EDITMSG setlocal spell
    " }

    " JavaScript {
    " }
" }

" Misc {
    " Sync edit file by bsync {
        autocmd BufWritePost * call system('bsync '.expand('%:p').' &')
    " }

    " Remove trailing whitespace {
        function! RemoveTrailingWhitespace()
            if &ft != "diff"
                let b:curcol = col(".")
                let b:curline = line(".")
                silent! %s/\s\+$//
                silent! %s/\(\s*\n\)\+\%$//
                call cursor(b:curline, b:curcol)
            endif
        endfunction

        autocmd BufWritePre *.js,*.less,*.vim,*.java call RemoveTrailingWhitespace()
    " }

    " Generate JavaScript tags {
        function! GenerateTag()
            let file = fnamemodify(findfile('jstags', '.;'), ':p')
            if executable(file)
                execute ':silent !' . file
            endif
        endfunction

        autocmd BufWritePost *.js call GenerateTag()
    " }
" }

" vim: set foldmarker={,} foldlevel=0 foldmethod=marker nospell:
